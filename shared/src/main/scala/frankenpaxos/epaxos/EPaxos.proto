// A protocol cheatsheet, similar to [1].
//
//   Client          Leader Replica        Other Replica
//      | ---------------> |                     |        ClientRequest
//      |                  | ------------------> |        PreAccept
//      |                  | <------------------ |        PreAcceptOk
//      |                  | ------------------> |        Accept
//      |                  | <------------------ |        AcceptOk
//      |                  | ------------------> |        Commit
//      | <--------------- |                     |        ClientReply
//      |                  | ------------------> |        Prepare
//      |                  | <------------------ |        PrepareOk
//      |                  | <------------------ |        Nack
//
// [1]: https://ndpsoftware.com/git-cheatsheet.html

syntax = "proto2";

package frankenpaxos.epaxos;

import "scalapb/scalapb.proto";

option (scalapb.options) = {
  package_name: "frankenpaxos.epaxos"
  flat_package: true
};


// Helper messages. ////////////////////////////////////////////////////////////
message Command {
  // The client's address.
  required bytes client_address = 1;

  // Clients annotate every command with a unique and monotonically increasing
  // id. The pair of (client address, client id) uniquely identify a command.
  required int32 client_id = 2;

  required bytes command = 3;
}

// Every ballot has the form `ordering.replica_index` where `ordering` is a
// monotonically increasing integer and `replica_index` is the unique index of
// the replica.
message Ballot {
  required int32 ordering = 1;
  required int32 replica_index = 2;
}

// Every instance is of the form `leader_index.instance_number` where
// `leader_index` is the unique index of the leader and `instance_number` is a
// monotonically increasing integer. In the EPaxos paper, for example, these
// are written like R.1 or Q.2.
message Instance {
  // TODO(mwhittaker): Maybe rename to replica_index.
  required int32 replica_index = 1;
  required int32 instance_number = 2;
}

enum CommandStatus {
  PreAccepted = 0;
  Accepted = 1;
  Committed = 2;
  Executed = 3;
}

// Protocol messages. //////////////////////////////////////////////////////////
message ClientRequest {
  required Command command = 1;
}

message PreAccept {
  // The command, sequence number, and dependencies. In the EPaxos paper, this
  // is written as the triple (\gamma, seq_\gamma, deps_\gamma).
  required Command command = 1;
  required int32 sequence_number = 2;
  repeated Instance dependencies = 3;

  // The instance in which this command is being chosen.
  required Instance instance = 4;

  // The message's ballot. As with Paxos, every command is annotated with a
  // ballot. Replicas ignore messages from smaller ballots.
  required Ballot ballot = 5;
}

message PreAcceptOk {
  // TODO(mwhittaker): Does the command need to be included?
  required Command command = 1;
  required int32 sequence_number = 2;
  repeated Instance dependencies = 3;
  required Instance instance = 4;
  required Ballot ballot = 6;
  required int32 replica_index = 7;
}

message Accept {
  required Command command = 1;
  required int32 sequence_number = 2;
  repeated Instance dependencies = 3;
  required Instance instance = 4;
  required Ballot ballot = 6;
}

message AcceptOk {
  // TODO(mwhittaker): Does the command need to be included?
  required Command command = 1;
  required Instance instance = 2;
  required Ballot ballot = 3;
  required int32 replica_index = 7;
}

message Commit {
  required Command command = 1;
  required int32 sequence_number = 2;
  repeated Instance dependencies = 3;
  required Instance instance = 4;
  // TODO(mwhittaker): Do you need ballot in a commit?
  required Ballot ballot = 5;
}

message ClientReply {
  // TODO(mwhittaker): Add reply bytes.
  required Command command = 1;
  required Instance instance = 2;
}

message Prepare {
  required Ballot ballot = 1;
  required Instance instance = 2;
}

message PrepareOk {
  required Ballot ballot = 1;
  required Instance instance = 2;
  required int32 replica_index = 3;

  // When a replica receives a Prepare in instance I, it's possible that the
  // replica has never seen any command in instance I yet. In this case,
  // voteBallot is set to the null ballot Ballot(-1, -1) and all remaining
  // fields are left empty.
  required Ballot vote_ballot = 4;
  optional Command command = 5;
  optional int32 sequence_number = 6;
  repeated Instance dependencies = 7;
  optional CommandStatus status = 8;
}

message Nack {
  required Instance instance = 1;
  required Ballot largest_ballot = 2;
}


// Inbound messages. ///////////////////////////////////////////////////////////
message ReplicaInbound {
  oneof request {
    ClientRequest client_request = 1;
    PreAccept pre_accept = 2;
    PreAcceptOk pre_accept_ok = 3;
    Accept accept = 4;
    AcceptOk accept_ok = 5;
    Commit commit = 6;
    Prepare prepare = 7;
    PrepareOk prepare_ok = 8;
    Nack nack = 9;
  }
}

message ClientInbound {
  oneof request {
    ClientReply client_reply = 1;
  }
}
