// A protocol cheatsheet, similar to [1].
//
// Normal case operation.
//
//   Client    Leader  Matchmaker Acceptor  Replica
//     |         | ------> |         |         |     MatchRequest
//     |         | <------ |         |         |     MatchReply
//     |         | --------^-------> |         |     Phase1a
//     |         | <-------^-------- |         |     Phase1b
//     | ------> |         |         |         |     ClientRequest
//     |         | --------^-------> |         |     Phase2a
//     |         | <-------^-------- |         |     Phase2b
//     |         | --------^---------^-------> |     Chosen
//     |         | -----.  |         |         |     ChosenWatermark
//     |         | <----'  |         |         |
//     | <-------^---------^---------^-------- |     ClientReply
//
// Abnormal case operation.
//
//   Client    Leader  Matchmaker Acceptor  Replica
//     | <------ |         |         |         |     NotLeader
//     | ------> |         |         |         |     LeaderInfoRequest
//     | <------ |         |         |         |     LeaderInfoReply
//     |         | <------ |         |         |     MatchmakerNack
//     |         | <------ |         |         |     Stopped
//     |         | <-------^-------- |         |     AcceptorNack
//     |         | <-------^---------^-------- |     Recover
//     |         |         |         |    .--- |     Recover
//     |         |         |         |    '--> |
//
// Garbage collection.
//
//   Client    Leader  Matchmaker Acceptor  Replica
//     |         | --------^---------^-------> |     ExecutedWatermarkRequest
//     |         | <-------^---------^-------- |     ExecutedWatermarkReply
//     |         | --------^-------> |         |     Persisted
//     |         | <-------^-------- |         |     PersistedAck
//     |         | ------> |         |         |     GarbageCollect
//     |         | <------ |         |         |     GarbageCollectAck
//
// Matchmaker reconfiguration.
//
//   Client    Leader  Matchmaker Acceptor  Replica
//     |         | ------> |         |         |     StopRequest
//     |         | <------ |         |         |     StopReply
//     |         | --------^-------> |         |     BootstrapEpochRequest
//     |         | <-------^-------- |         |     BootstrapEpochReply
//     |         | ------> |         |         |     Phase1a
//     |         | <------ |         |         |     Phase1b
//     |         | ------> |         |         |     Phase2a
//     |         | <------ |         |         |     Phase2b
//     |         | -----.  |         |         |     StartEpoch
//     |         | <----'  |         |         |
//     |         | --------^-------> |         |     StartEpoch
//
// TODO(mwhittaker): Add recovery. If a replica notices a hole in its log, it
// should send a recover to the leader and to the other replicas. The replicas
// should respond if it has the missing entry. The leader should do a leader
// change with a smaller than usual chosenWatermark to make sure the value gets
// chosen appropriately.

// TODO(mwhittaker): Add garbage collection. This will require us to have
// replicas ack the execution of commands so that the leader knows when things
// are safe to GC.
//
// [1]: https://ndpsoftware.com/git-cheatsheet.html

syntax = "proto2";

package frankenpaxos.matchmakermultipaxos;

import "scalapb/scalapb.proto";
import "frankenpaxos/quorums/QuorumSystem.proto";

option (scalapb.options) = {
  package_name: "frankenpaxos.matchmakermultipaxos"
  flat_package: true
};

// Helper messages. ////////////////////////////////////////////////////////////
message Noop {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";
}

message CommandId {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  // A client's address, pseudonym, and id uniquely identify a command.
  required bytes client_address = 1;
  required int32 client_pseudonym = 2;
  required int32 client_id = 3;
}

message Command {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required CommandId command_id = 1;
  required bytes command = 2;
}

message CommandOrNoop {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  oneof value {
    Command command = 1;
    Noop noop = 2;
  }
}

message Configuration {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required int32 round = 1;
  required quorums.QuorumSystemProto quorum_system = 2;
}

message Phase1bSlotInfo {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required int32 slot = 1;
  required int32 vote_round = 2;
  required CommandOrNoop vote_value = 3;
}

// Normal case operations. /////////////////////////////////////////////////////
message MatchRequest {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required Configuration configuration = 1;
}

message MatchReply {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required int32 round = 1;
  required int32 matchmaker_index = 2;
  // All configurations in rounds less than `gc_watermark` have been garbage
  // collected and should be ignored by the leader.  Note that `configuration`
  // won't include a configuration in a round less than `gc_watermark`, but
  // other MatchReplies received by the leader might.
  required int32 gc_watermark = 3;
  repeated Configuration configuration = 4;
}

message Phase1a {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required int32 round = 1;

  // The leader knows that all entries in slots less than `chosenWatermark`
  // have been chosen. Acceptors do not have to include slots below
  // `chosenWatermark` in their phase1b response.
  //
  // The leader may know that some entries larger than `chosenWatermark` have
  // also been chosen, but that's okay. It's not unsafe for acceptors to return
  // too much information.
  required int32 chosen_watermark = 2;
}

message Phase1b {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required int32 round = 1;
  required int32 acceptor_index = 2;
  // All commands in slots less than persisted_watermark have already been
  // chosen and persisted on at least f+1 replicas. There is no need to run
  // Phase 2 for these slots since they are already chosen.
  required int32 persisted_watermark = 3;
  repeated Phase1bSlotInfo info = 4;
}

message ClientRequest {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required Command command = 1;
}

message Phase2a {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required int32 slot = 1;
  required int32 round = 2;
  required CommandOrNoop value = 3;
}

message Phase2b {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required int32 slot = 1;
  required int32 round = 2;
  required int32 acceptor_index = 3;
  required bool persisted = 4;
}

message Chosen {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required int32 slot = 1;
  required CommandOrNoop value = 2;
}

message ChosenWatermark {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  // All slots less than `watermark` have been chosen.
  required int32 watermark = 1;
}

message ClientReply {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required CommandId command_id = 1;
  required bytes result = 2;
}

// Abnormal case operations. ///////////////////////////////////////////////////
message NotLeader {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";
}

message LeaderInfoRequest {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";
}

message LeaderInfoReply {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  // The round of the leader (hopefully).
  required int32 round = 1;
}

message MatchmakerNack {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  // The leader should retry with a round at least as large as round.
  required int32 round = 1;
}

message Stopped {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  // TODO(mwhittaker): Implement.
}

message AcceptorNack {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required int32 round = 1;
}

message Recover {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  // Replicas execute logs in prefix order. Thus, if the log permanently has a
  // hole in it, the algorithm remains forever blocked. To solve this, if a
  // replica notices a hole in its log for a certain amount of time, it sends a
  // Recover message to the leader to get the hole plugged.
  required int32 slot = 1;
}

// Garbage Collection. /////////////////////////////////////////////////////////
message ExecutedWatermarkRequest {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";
}

message ExecutedWatermarkReply {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  // Replica `replica_index` has executed all commands in slots less than
  // `executed_watermark`.
  required int32 replica_index = 1;
  required int32 executed_watermark = 2;
}

message Persisted {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  // All commands in slots less than persisted_watermark have been stored on at
  // least f + 1 replicas.
  required int32 persisted_watermark = 1;
}

message PersistedAck {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required int32 acceptor_index = 1;
}

message GarbageCollect {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  // Garbage collect all rounds less than `gc_watermark`.
  required int32 gc_watermark = 1;
}

message GarbageCollectAck {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required int32 matchmaker_index = 1;
}

// Inbound messages. ///////////////////////////////////////////////////////////
message ClientInbound {
  oneof request {
    ClientReply client_reply = 1;
    NotLeader not_leader = 2;
    LeaderInfoReply leader_info_reply = 3;
  }
}

message LeaderInbound {
  oneof request {
    MatchReply match_reply = 1;
    Phase1b phase1b = 2;
    ClientRequest client_request = 3;
    Phase2b phase2b = 4;
    LeaderInfoRequest leader_info_request = 5;
    ChosenWatermark chosen_watermark = 6;
    MatchmakerNack matchmaker_nack = 7;
    Stopped stopped = 8;
    AcceptorNack acceptor_nack = 9;
    Recover recover = 10;
    ExecutedWatermarkReply executed_watermark_reply = 11;
    PersistedAck persisted_ack = 12;
    GarbageCollectAck garbage_collect_ack = 13;
  }
}

message MatchmakerInbound {
  oneof request {
    MatchRequest match_request = 1;
    GarbageCollect garbage_collect = 2;
  }
}

message AcceptorInbound {
  oneof request {
    Phase1a phase1a = 1;
    Phase2a phase2a = 2;
    Persisted persisted = 3;
  }
}

message ReplicaInbound {
  oneof request {
    Chosen chosen = 1;
    Recover recover = 2;
    ExecutedWatermarkRequest executed_watermark_request = 3;
  }
}
